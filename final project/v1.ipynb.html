<html>
<head>
<title>v1.ipynb</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #a9b7c6;}
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
v1.ipynb</font>
</center></td></tr></table>
<pre><span class="s0">{ 
 &quot;cells&quot;: [ 
  { 
   &quot;cell_type&quot;: &quot;markdown&quot;, 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;jupyter&quot;: { 
     &quot;outputs_hidden&quot;: false 
    } 
   }, 
   &quot;source&quot;: [ 
    &quot;# Part 1: Volatility Arb with improved GBM and Monte-Carlo\n&quot;, 
    &quot;\n&quot;, 
    &quot;## Sub-part 1: Consider improvements to GBM asset evolution (using Milstein schemes)\n&quot;, 
    &quot;\n&quot;, 
    &quot;Volatility Arb (Volatility Arbitrage): This refers to a strategy that exploits the difference between realized volatility in the market and the implied volatility of option prices. By hedging against changes in volatility, investors attempt to profit from variations between different options.\n&quot;, 
    &quot;\n&quot;, 
    &quot;Improved GBM (Improved Geometric Brownian Motion): Typically, geometric Brownian motion is used to simulate the price evolution of financial assets. Here, we can use either the Euler-Maruyama or Milstein methods to simulate the asset evolution of geometric Brownian motion (GBM).\n&quot;, 
    &quot;\n&quot;, 
    &quot;The basic idea of the Euler-Maruyama method is to approximate the evolution over a small-time step as a constant, introducing a random term to simulate volatility.\n&quot;, 
    &quot;\n&quot;, 
    &quot;The typical Euler-Maruyama evolution formula is: $$S_{t + \\Delta t} = S_t + \\mu S_t \\Delta t + \\sigma S_t \\sqrt{\\Delta t} Z$$, where $\\mu$ is the drift rate of the asset, $\\sigma$ is the volatility of the asset, and $Z$ is a standard normal distribution random variable.\n&quot;, 
    &quot;\n&quot;, 
    &quot;On the other hand, the Milstein method is an improvement over Euler-Maruyama, especially suitable for SDEs with stochastic volatility. By correcting for the derivative of volatility, it more accurately captures the evolution of volatility.\n&quot;, 
    &quot;\n&quot;, 
    &quot;The Milstein evolution formula is: $$S_{t + \\Delta t} = S_t + \\mu S_t \\Delta t + \\sigma S_t \\sqrt{\\Delta t} Z + \\frac{1}{2} \\sigma S_t \\sigma' (\\Delta t Z^2 - \\Delta t)$$, where $\\mu$, $\\sigma$, and $Z$ have the same meanings as above, and $\\sigma'$ is the second derivative of volatility.\n&quot;, 
    &quot;\n&quot;, 
    &quot;The Milstein method is an improvement over Euler-Maruyama, especially suitable for models with stochastic volatility, providing more accurate results but with relatively higher computational complexity. In this paper, we will use the Milstein method to improve GBM.&quot; 
   ] 
  }, 
  { 
   &quot;cell_type&quot;: &quot;markdown&quot;, 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;jupyter&quot;: { 
     &quot;outputs_hidden&quot;: false 
    } 
   }, 
   &quot;source&quot;: [ 
    &quot;### What is Milstein method?\n&quot;, 
    &quot;\n&quot;, 
    &quot;When using the Milstein method to simulate the asset evolution of geometric Brownian motion (GBM), it is typically done by approximating the stochastic differential equation (SDE) to obtain changes in asset prices over future time steps. Here are the detailed mathematical steps for simulating using the Milstein method:\n&quot;, 
    &quot;\n&quot;, 
    &quot;We already have the SDE for GBM: $$ dS_t = \\mu S_t dt + \\sigma S_t dW_t $$\n&quot;, 
    &quot;\n&quot;, 
    &quot;#### 1. Taylor Expansion\n&quot;, 
    &quot;\n&quot;, 
    &quot;We perform a Taylor expansion on the asset price $S_t$ over the time step $\\Delta t$. The first-order Taylor expansion formula is: $$ S_{t + \\Delta t} \\approx S_t + S_t' \\Delta t $$, where $S_t'$ is the first derivative of the asset price with respect to time.\n&quot;, 
    &quot;\n&quot;, 
    &quot;#### 2. Compute Second Derivative\n&quot;, 
    &quot;\n&quot;, 
    &quot;We calculate the second derivative of the asset price with respect to time. We know the first derivative of the asset price $S_t$ is: $$ S_t' = \\mu S_t + \\sigma S_t' W_t $$\n&quot;, 
    &quot;\n&quot;, 
    &quot;Now, we will calculate the second derivative with respect to time of this first derivative.\n&quot;, 
    &quot;\n&quot;, 
    &quot;First, differentiate the first derivative $S_t'$ with respect to time $t$: $$ \\frac{dS_t'}{dt} = \\mu' S_t + \\sigma S_t'' W_t $$, where $\\mu'$ represents the derivative of $\\mu$ with respect to time, and $S_t''$ is the second derivative of $S_t'$ with respect to time. Since $\\mu$ is a constant, $\\mu'$ is zero.\n&quot;, 
    &quot;\n&quot;, 
    &quot;Next, we need to calculate $S_t''$, which is the first derivative $S_t'$ with respect to time. Substitute the expression for the first derivative into the above equation: $$ \\frac{dS_t'}{dt} = \\sigma \\left( S_t'' W_t + S_t' \\frac{dW_t}{dt} \\right) $$\n&quot;, 
    &quot;\n&quot;, 
    &quot;Note that the derivative of the Brownian motion $W_t$ is white noise, i.e., $\\frac{dW_t}{dt} = \\eta_t$, where $\\eta_t$ is a standard normal distribution random variable.\n&quot;, 
    &quot;\n&quot;, 
    &quot;#### 3. Apply to Evolution Formula\n&quot;, 
    &quot;\n&quot;, 
    &quot;Apply the second derivative $S_t''$ to the Taylor expansion evolution formula: $$ S_{t + \\Delta t} \\approx S_t + \\left( \\mu S_t + \\sigma S_t' W_t + \\frac{1}{2} \\sigma^2 S_t' \\eta_t \\right) \\Delta t $$. This is the asset evolution formula that considers the second derivative of volatility.&quot; 
   ] 
  }, 
  { 
   &quot;cell_type&quot;: &quot;markdown&quot;, 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;jupyter&quot;: { 
     &quot;outputs_hidden&quot;: false 
    } 
   }, 
   &quot;source&quot;: [ 
    &quot;### What is low differentiation sequences and Brownian bridges?\n&quot;, 
    &quot;\n&quot;, 
    &quot;#### 1. For Low Discrepancy Sequences:\n&quot;, 
    &quot;\n&quot;, 
    &quot;Low Discrepancy Sequences are sets of points arranged according to certain rules, aiming to uniformly cover the sample space in high-dimensional settings. One common low discrepancy sequence is the Sobol sequence. Mathematically, low discrepancy sequences seek to minimize the discrepancy between the set points. This can be understood through the following mathematical definition:\n&quot;, 
    &quot;\n&quot;, 
    &quot;Let $ P = \\{p_1, p_2, \\ldots, p_n\\} $ be a set of points, and $ V(P) $ be the volume enclosing the point set $ P $. The discrepancy $ D(P) $ of the point set $ P $ is defined as: $$ D(P) = \\sup_{I} \\left| \\frac{V(P \\cap I)}{V(I)} - \\frac{|P|}{|I|} \\right| $$\n&quot;, 
    &quot;\n&quot;, 
    &quot;Here, $ I $ is an interval in the sample space, and $ |P| $ and $ |I| $ are the volumes of the set $ P $ and the interval $ I $, respectively. The goal of a low discrepancy sequence is to minimize the discrepancy.\n&quot;, 
    &quot;\n&quot;, 
    &quot;#### 2. For Brownian Bridge:\n&quot;, 
    &quot;\n&quot;, 
    &quot;The Brownian Bridge is a variation of Brownian motion, characterized by a continuous sample path that is not everywhere differentiable. The Brownian Bridge $ B_t $ can be defined in terms of Brownian motion $ W_t $ as: $$ B_t = W_t - tW_1 $$. Here, $ t $ is the time parameter. Mathematically, the path of the Brownian Bridge is continuous everywhere but not differentiable everywhere. Specifically, it satisfies Holder continuity, meaning there exist constants $ C $ and $ \\alpha $ such that for all $ s, t $: $$ |B_t - B_s| \\leq C|t - s|^\\alpha $$\n&quot;, 
    &quot;\n&quot;, 
    &quot;This indicates that the path of the Brownian Bridge does not exhibit sudden changes like Brownian motion but possesses a certain level of smoothness within small time intervals.&quot; 
   ] 
  }, 
  { 
   &quot;cell_type&quot;: &quot;markdown&quot;, 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false, 
    &quot;jupyter&quot;: { 
     &quot;outputs_hidden&quot;: false 
    } 
   }, 
   &quot;source&quot;: [ 
    &quot;## Sub-part 2: Under the condition of known $ V_a &gt; V_i $, analytically and with Monte-Carlo confirm the items below.\n&quot;, 
    &quot;\n&quot;, 
    &quot;+ Confirm that actual volatility hedges lead to known aggregate $P\\&amp;L$.\n&quot;, 
    &quot;\n&quot;, 
    &quot;+ Confirm and demonstrate that implied volatility hedges lead to uncertain aggregate, path-dependent $P\\&amp;L$ and describe which parameters/Greeks they depend on.\n&quot;, 
    &quot;\n&quot;, 
    &quot;**Here is the theoretical analysis:**&quot; 
   ] 
  }, 
  { 
   &quot;cell_type&quot;: &quot;markdown&quot;, 
   &quot;source&quot;: [ 
    &quot;### (1) Actual Volatility Hedging\n&quot;, 
    &quot;\n&quot;, 
    &quot;#### 1. Using Milstein Schemes to Improve the GBM Model:\n&quot;, 
    &quot;\n&quot;, 
    &quot;As mentioned above, we use the Sobol sequence to generate a Brownian bridge and apply it to the Milstein schemes to improve the GBM model, resulting in the asset price evolution formula: $$ S_{t + \\Delta t} \\approx S_t + \\left( \\mu S_t + \\sigma S_t' W_t + \\frac{1}{2} \\sigma^2 S_t' \\eta_t \\right) \\Delta t $$\n&quot;, 
    &quot;\n&quot;, 
    &quot;#### 2. Calculating the Option Price under Actual Volatility:\n&quot;, 
    &quot;\n&quot;, 
    &quot;This is substituted into the Black-Scholes option pricing formula. We still consider the European call option, whose price is given by: $$ C_t = S_tN(d_1) - Ke^{-r(T-t)}N(d_2) $$. Where, $$ d_1 = \\frac{\\ln(S_t/K) + (r + \\frac{1}{2}\\sigma^2)(T - t)}{\\sigma\\sqrt{T-t}} $$, $$ d_2 = d_1 - \\sigma\\sqrt{T-t} $$\n&quot;, 
    &quot;\n&quot;, 
    &quot;Substitute the evolution formula into the Black-Scholes formula: $$ C_{t+\\Delta t} = \\left(S_t + \\left( \\mu S_t + \\sigma S_t' W_t + \\frac{1}{2} \\sigma^2 S_t' \\eta_t \\right) \\Delta t\\right)N(d_{1,\\Delta t}) - Ke^{-r(T-(t+\\Delta t))}N(d_{2,\\Delta t}) $$. Where, $$ d_{1,\\Delta t} = \\frac{\\ln\\left(\\frac{S_t + \\left( \\mu S_t + \\sigma S_t' W_t + \\frac{1}{2} \\sigma^2 S_t' \\eta_t \\right) \\Delta t}{K}\\right) + \\left(r + \\frac{1}{2}\\sigma^2\\right)(T - (t + \\Delta t))}{\\sigma\\sqrt{T-(t+\\Delta t)}} $$, $$ d_{2,\\Delta t} = d_{1,\\Delta t} - \\sigma\\sqrt{T-(t+\\Delta t)} $$\n&quot;, 
    &quot;\n&quot;, 
    &quot;#### 3. Deriving the Delta Hedging Strategy and Calculating the Hedging Cost:\n&quot;, 
    &quot;\n&quot;, 
    &quot;+ Calculate the Delta value of the Delta hedging strategy: We already know the Delta formula for the option price with respect to the asset price: $$ \\Delta_t = N(d_{1,\\Delta t}) $$. Where, $$ d_{1,\\Delta t} = \\frac{\\ln\\left(\\frac{S_t + \\left( \\mu S_t + \\sigma S_t' W_t + \\frac{1}{2} \\sigma^2 S_t' \\eta_t \\right) \\Delta t}{K}\\right) + \\left(r + \\frac{1}{2}\\sigma^2\\right)(T - (t + \\Delta t))}{\\sigma\\sqrt{T-(t+\\Delta t)}} $$\n&quot;, 
    &quot;\n&quot;, 
    &quot;+ Calculate the hedging cost: The general formula for hedging cost is: $$ \\text{Hedging Cost} = \\Delta_t \\cdot (S_{t+\\Delta t} - S_t) - (C_{t+\\Delta t} - C_t) $$. Where, $$ S_{t+\\Delta t} \\approx S_t + \\left( \\mu S_t + \\sigma S_t' W_t + \\frac{1}{2} \\sigma^2 S_t' \\eta_t \\right) \\Delta t $$\n&quot;, 
    &quot;\n&quot;, 
    &quot;+ We substitute these formulas into the hedging cost formula: $$ \\text{Hedging Cost} = N(d_{1,\\Delta t}) \\cdot \\left[\\left(S_t + \\left( \\mu S_t + \\sigma S_t' W_t + \\frac{1}{2} \\sigma^2 S_t' \\eta_t \\right) \\Delta t\\right) - S_t\\right] - \\left(C_{t+\\Delta t} - C_t\\right) $$\n&quot;, 
    &quot;\n&quot;, 
    &quot;- Calculate $d_{1,\\Delta t}$:\n&quot;, 
    &quot;\n&quot;, 
    &quot;$$ d_{1,\\Delta t} = \\frac{\\ln\\left(\\frac{S_t + \\left( \\mu S_t + \\sigma S_t' W_t + \\frac{1}{2} \\sigma^2 S_t' \\eta_t \\right) \\Delta t}{K}\\right) + \\left(r + \\frac{1}{2}\\sigma^2\\right)(T - (t + \\Delta t))}{\\sigma\\sqrt{T-(t+\\Delta t)}} $$\n&quot;, 
    &quot;\n&quot;, 
    &quot;- Calculate $\\Delta_t$:\n&quot;, 
    &quot;\n&quot;, 
    &quot;$$ \\Delta_t = N(d_{1,\\Delta t}) $$\n&quot;, 
    &quot;\n&quot;, 
    &quot;- Calculate the future asset price $S_{t+\\Delta t}$:\n&quot;, 
    &quot;\n&quot;, 
    &quot;$$ S_{t+\\Delta t} \\approx S_t + \\left( \\mu S_t + \\sigma S_t' W_t + \\frac{1}{2} \\sigma^2 S_t' \\eta_t \\right) \\Delta t $$\n&quot;, 
    &quot;\n&quot;, 
    &quot;- Calculate the hedging cost:\n&quot;, 
    &quot;\n&quot;, 
    &quot;$$ \\text{Hedging Cost} = N(d_{1,\\Delta t}) \\cdot \\left[\\left(S_t + \\left( \\mu S_t + \\sigma S_t' W_t + \\frac{1}{2} \\sigma^2 S_t' \\eta_t \\right) \\Delta t\\right) - S_t\\right] - \\left(C_{t+\\Delta t} - C_t\\right) $$\n&quot;, 
    &quot;\n&quot;, 
    &quot;#### 4. Confirming that under known realized volatility, actual volatility hedging will result in a known total $P\\&amp;L$:\n&quot;, 
    &quot;\n&quot;, 
    &quot;- Substituting the actual volatility: When calculating $d_{1,\\Delta t}$, substitute the actual volatility $\\sigma_{\\text{actual}}$ into the model: $$ d_{1,\\Delta t} = \\frac{\\ln\\left(\\frac{S_t + \\left( \\mu S_t + \\sigma_{\\text{actual}} S_t' W_t + \\frac{1}{2} \\sigma_{\\text{actual}}^2 S_t' \\eta_t \\right) \\Delta t}{K}\\right) + \\left(r + \\frac{1}{2}\\sigma_{\\text{actual}}^2\\right)(T - (t + \\Delta t))}{\\sigma_{\\text{actual}}\\sqrt{T-(t+\\Delta t)}} $$, This gives $d_{1,\\Delta t}$ under the actual volatility\n&quot;, 
    &quot;\n&quot;, 
    &quot;- Calculate the Delta value of the Delta hedging strategy using known parameters and actual volatility: $$ \\Delta_t = N(d_{1,\\Delta t}) $$, This is the Delta value in the Delta hedging strategy\n&quot;, 
    &quot;\n&quot;, 
    &quot;    - Calculate the hedging cost corresponding to the Delta value of the Delta hedging under the original volatility $\\sigma$: $$ \\text{Hedging Cost} = N(d_{1,\\Delta t}) \\cdot \\left[\\left(S_t + \\left( \\mu S_t + \\sigma S_t' W_t + \\frac{1}{2} \\sigma^2 S_t' \\eta_t\\right) \\Delta t\\right) - S_t\\right] - \\left(C_{t+\\Delta t} - C_t\\right) $$\n&quot;, 
    &quot;\n&quot;, 
    &quot;    - Adjust the quantity of Delta based on the relationship between the target total $P\\&amp;L$ and the hedging cost. This can be achieved by the following formula: $$ \\text{Adjusted Delta} = \\frac{\\text{Target Total P\\&amp;L} + \\text{Hedging Cost}}{S_{t+\\Delta t} - S_t} $$, This gives the adjusted Delta value of the Delta hedging\n&quot;, 
    &quot;\n&quot;, 
    &quot;#### 5. Calculate the adjusted hedging cost using actual volatility and confirm whether the total $P\\&amp;L$ equals the target total $P\\&amp;L$:\n&quot;, 
    &quot;\n&quot;, 
    &quot;$$ \\text{Adjusted Hedging Cost} = N(d_{1,\\Delta t}) \\cdot \\left[ \\left( S_t + \\left( \\mu S_t + \\sigma_{\\text{actual}} S_t' W_t + \\frac{1}{2} \\sigma_{\\text{actual}}^2 S_t' \\eta_t \\right) \\Delta t \\right) - S_t \\right] - \\left( C_{t+\\Delta t} - C_t \\right) $$\n&quot;, 
    &quot;\n&quot;, 
    &quot;#### 6. With the specific expression for the hedging cost at hand, we can substitute it into the formula for calculating the total P&amp;L and proceed with simplification. First, let's list the expressions to be substituted:\n&quot;, 
    &quot;\n&quot;, 
    &quot;**Hedging Cost ($\\text{Hedging Cost}$)**:\n&quot;, 
    &quot;$$ \\text{Hedging Cost} = N(d_{1,\\Delta t}) \\cdot \\left[\\left(S_t + \\left( \\mu S_t + \\sigma S_t' W_t + \\frac{1}{2} \\sigma^2 S_t' \\eta_t \\right) \\Delta t\\right) - S_t\\right] - \\left(C_{t+\\Delta t} - C_t\\right) $$\n&quot;, 
    &quot;\n&quot;, 
    &quot;**Adjusted Delta ($\\text{Adjusted Delta}$)**:\n&quot;, 
    &quot;$$ \\text{Adjusted Delta} = \\frac{\\text{Target Total P\\&amp;L} + \\text{Hedging Cost}}{S_{t+\\Delta t} - S_t} $$\n&quot;, 
    &quot;\n&quot;, 
    &quot;**Total P&amp;L ($\\text{Adjusted Total P\\&amp;L}$)**:\n&quot;, 
    &quot;$$ \\text{Adjusted Total P\\&amp;L} = S_t \\cdot \\text{Adjusted Delta} - C_t - \\text{Adjusted Hedging Cost} $$\n&quot;, 
    &quot;\n&quot;, 
    &quot;**Now, we substitute $\\text{Hedging Cost}$ and $\\text{Adjusted Delta}$ into the formula for $\\text{Adjusted Total P\\&amp;L}$**:\n&quot;, 
    &quot;$$ \\text{Adjusted Total P\\&amp;L} = S_t \\cdot \\left(\\frac{\\text{Target Total P\\&amp;L} + N(d_{1,\\Delta t}) \\cdot \\left[\\left(S_t + \\left( \\mu S_t + \\sigma S_t' W_t + \\frac{1}{2} \\sigma^2 S_t' \\eta_t \\right) \\Delta t\\right) - S_t\\right] - \\left(C_{t+\\Delta t} - C_t\\right)}{S_{t+\\Delta t} - S_t}\\right) - C_t - \\left( N(d_{1,\\Delta t}) \\cdot \\left[\\left(S_t + \\left( \\mu S_t + \\sigma S_t' W_t + \\frac{1}{2} \\sigma^2 S_t' \\eta_t \\right) \\Delta t\\right) - S_t\\right] - \\left(C_{t+\\Delta t} - C_t\\right) \\right) $$\n&quot;, 
    &quot;\n&quot;, 
    &quot;**Next, we note that $\\text{Hedging Cost}$ appears twice in the formula, and in the same way, we can combine them for simplification. Additionally, $C_t$ also appears twice with opposite signs, which can cancel each other out. The simplified formula is:**\n&quot;, 
    &quot;$$ \\text{Adjusted Total P\\&amp;L} = S_t \\cdot \\left(\\frac{\\text{Target Total P\\&amp;L}}{S_{t+\\Delta t} - S_t}\\right) + \\left(C_{t+\\Delta t} - C_t\\right) $$\n&quot;, 
    &quot;\n&quot;, 
    &quot;**In this simplified formula:**\n&quot;, 
    &quot;- $\\text{Target Total P\\&amp;L}$ is divided by the change in stock price, reflecting the relationship between the target total P&amp;L and the change in stock price.\n&quot;, 
    &quot;- The final result is associated with the change in option price $C_{t+\\Delta t} - C_t$.&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;markdown&quot;, 
   &quot;source&quot;: [ 
    &quot;### (2) Implied Volatility Hedging\n&quot;, 
    &quot;\n&quot;, 
    &quot;To rigorously integrate Greeks into the mathematical process of proving that implied volatility hedging results in uncertain and path-dependent total $P\\&amp;L$, we need to construct a more detailed model that reflects the impact of these Greeks on the hedging strategy. Below is a relatively detailed model and steps showing how these Greeks influence the $P\\&amp;L$ of the hedging strategy.\n&quot;, 
    &quot;\n&quot;, 
    &quot;#### 1. Asset Price Simulation:\n&quot;, 
    &quot;\n&quot;, 
    &quot;Asset price simulation still uses geometric Brownian motion, calculating the asset price for each time step $\\Delta t$ using the following equation:\n&quot;, 
    &quot;\n&quot;, 
    &quot;$$\n&quot;, 
    &quot;S_{t+\\Delta t} = S_t \\exp\\left(\\left(\\mu - \\frac{1}{2}\\sigma^2\\right)\\Delta t + \\sigma \\sqrt{\\Delta t} Z_t\\right)\n&quot;, 
    &quot;$$\n&quot;, 
    &quot;\n&quot;, 
    &quot;#### 2. Dynamic Execution of Hedging Strategy:\n&quot;, 
    &quot;\n&quot;, 
    &quot;This is a key step where we calculate and adjust the hedging position at each time point $t_i$. The hedging position is mainly determined by Delta, but is also influenced by other Greeks.\n&quot;, 
    &quot;\n&quot;, 
    &quot;**Calculating Delta ($\\Delta_{t_i}$) and Gamma ($\\Gamma_{t_i}$)**: Calculate Delta and Gamma using the Black-Scholes model. Delta is used to determine the hedging position, while Gamma is used to estimate the change in Delta.\n&quot;, 
    &quot;\n&quot;, 
    &quot;**Adjusting the Hedging Position**: The change in the hedging position $\\Delta S_{t_i}$ depends on the change in Delta. However, due to the influence of Gamma, the change in Delta is not linear, so we need to consider the change in the asset price's effect on Delta:\n&quot;, 
    &quot;\n&quot;, 
    &quot;$$\n&quot;, 
    &quot;\\Delta S_{t_i} = (S_{t_i} \\cdot \\Delta_{t_i}) - (S_{t_{i-1}} \\cdot \\Delta_{t_{i-1}}) + \\frac{1}{2} \\Gamma_{t_{i-1}} \\cdot (S_{t_i} - S_{t_{i-1}})^2\n&quot;, 
    &quot;$$\n&quot;, 
    &quot;\n&quot;, 
    &quot;#### 3. Calculating Hedging Costs and $P\\&amp;L$:\n&quot;, 
    &quot;\n&quot;, 
    &quot;**Calculating Transaction Costs**: Transaction costs are determined by the change in the asset price each time the position is adjusted. If $\\kappa$ represents the transaction cost per unit of asset, then the transaction cost at time $t_i$ is:\n&quot;, 
    &quot;\n&quot;, 
    &quot;$$\n&quot;, 
    &quot;\\text{Transaction Cost}_{t_i} = \\kappa \\cdot |\\Delta S_{t_i}|\n&quot;, 
    &quot;$$\n&quot;, 
    &quot;\n&quot;, 
    &quot;**Calculating Holding Costs**: Holding costs are determined by the cost of capital and the decay of the option's time value (Theta). If $c$ represents the cost of capital rate, then the holding cost can be expressed as:\n&quot;, 
    &quot;\n&quot;, 
    &quot;$$\n&quot;, 
    &quot;\\text{Holding Cost}_{t_i} = c \\cdot S_{t_i} \\cdot \\Delta_{t_i} \\cdot \\Delta t - \\Theta_{t_i} \\cdot \\Delta t\n&quot;, 
    &quot;$$\n&quot;, 
    &quot;\n&quot;, 
    &quot;**Total Hedging Cost is the sum of transaction costs and holding costs**:\n&quot;, 
    &quot;\n&quot;, 
    &quot;$$\n&quot;, 
    &quot;\\text{Total Hedging Cost} = \\sum_{i=1}^{n} \\left( \\text{Transaction Cost}_{t_i} + \\text{Holding Cost}_{t_i} \\right)\n&quot;, 
    &quot;$$\n&quot;, 
    &quot;\n&quot;, 
    &quot;**Total $P\\&amp;L$ considers the final payoff of the option, the final value of the hedging position, and the total hedging cost**:\n&quot;, 
    &quot;\n&quot;, 
    &quot;$$\n&quot;, 
    &quot;\\text{Total $P\\&amp;L$} = (S_{t_n} - K)^+ - (S_{t_n} - S_{t_0}) \\cdot \\Delta_{t_0} + \\sum_{i=1}^{n} \\left( (S_{t_i} - S_{t_{i-1}}) \\cdot \\Delta_{t_{i-1}} + \\frac{1}{2} \\Gamma_{t_{i-1}} \\cdot (S_{t_i} - S_{t_{i-1}})^2 \\right) - \\text{Total Hedging Cost}\n&quot;, 
    &quot;$$\n&quot;, 
    &quot;\n&quot;, 
    &quot;This model and equations reflect the role of Delta, Gamma, Vega, and Theta, among other Greeks, in hedging strategies and how they influence the $P\\&amp;L$. By simulating this model, we can demonstrate the uncertainty and path dependency of $P\\&amp;L$ resulting from implied volatility hedging. However, it's worth noting that such simulation requires appropriate market data and parameters, and in actual application, the model itself may have limitations, and market conditions can be very variable.&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;markdown&quot;, 
   &quot;source&quot;: [ 
    &quot;### (3) The total $P\\&amp;L$ of implied volatility hedging depends on multiple parameters and Greeks. Here are the most important factors in the hedging strategy and their impact on $P\\&amp;L$:\n&quot;, 
    &quot;\n&quot;, 
    &quot;1. **Implied Volatility (IV)**:\n&quot;, 
    &quot;    - Implied volatility represents the market's expectation of the future volatility of the asset's price. Changes in implied volatility directly affect the price of options, especially those that are far from the expiration date, where the impact is more significant.\n&quot;, 
    &quot;\n&quot;, 
    &quot;2. **Delta (Δ)**:\n&quot;, 
    &quot;    - Delta represents the sensitivity of the option's price to changes in the price of the underlying asset. Hedging strategies typically aim to maintain a Delta-neutral position, reducing the direct impact of asset price changes on $P\\&amp;L$.\n&quot;, 
    &quot;\n&quot;, 
    &quot;3. **Gamma (Γ)**:\n&quot;, 
    &quot;    - Gamma represents the sensitivity of Delta to changes in the price of the underlying asset. A high Gamma value means that small changes in the asset's price may lead to significant changes in Delta, potentially increasing hedging costs due to the need for more frequent adjustments of the hedging position.\n&quot;, 
    &quot;\n&quot;, 
    &quot;4. **Vega (ν)**:\n&quot;, 
    &quot;    - Vega represents the sensitivity of the option's price to changes in volatility. Changes in implied volatility affect the time value and the overall value of the option, thereby affecting the hedging strategy's $P\\&amp;L$.\n&quot;, 
    &quot;\n&quot;, 
    &quot;5. **Theta (Θ)**:\n&quot;, 
    &quot;    - Theta represents the rate at which the option's value decays over time. Theta affects the value of the hedging position over time, especially as the option approaches its expiration date, where the impact of Theta becomes more pronounced.\n&quot;, 
    &quot;\n&quot;, 
    &quot;6. **Rho (ρ)**:\n&quot;, 
    &quot;    - Rho represents the sensitivity of the option's price to changes in the risk-free interest rate. In market environments where interest rates change significantly, Rho can have a substantial impact on $P\\&amp;L$.\n&quot;, 
    &quot;\n&quot;, 
    &quot;7. **Expiration Time (T)**:\n&quot;, 
    &quot;    - The expiration time of the option affects the time value of the option. The longer the time until expiration, the higher the time value of the option. The passage of time (Theta) causes the option's value to decay, thereby affecting the hedging strategy's $P\\&amp;L$.\n&quot;, 
    &quot;\n&quot;, 
    &quot;8. **Volatility Skew**:\n&quot;, 
    &quot;    - The volatility skew describes the relationship between implied volatilities of options with different strike prices. Changes in the volatility skew can affect the $P\\&amp;L$ of hedging strategies involving options with different strike prices.\n&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;markdown&quot;, 
   &quot;source&quot;: [ 
    &quot;### (4) Monte Carlo simulation\n&quot;, 
    &quot;\n&quot;, 
    &quot;```python\n&quot;, 
    &quot;import numpy as np\n&quot;, 
    &quot;import scipy.stats as stats\n&quot;, 
    &quot;from sobol_seq import i4_sobol_generate\n&quot;, 
    &quot;\n&quot;, 
    &quot;# Parameter settings\n&quot;, 
    &quot;S0 = 100  # Initial stock price\n&quot;, 
    &quot;K = 100   # Strike price\n&quot;, 
    &quot;T = 1.0   # Time to maturity\n&quot;, 
    &quot;r = 0.05  # Risk-free rate\n&quot;, 
    &quot;sigma_actual = 0.3  # Actual volatility\n&quot;, 
    &quot;sigma_iv = 0.2      # Implied volatility\n&quot;, 
    &quot;mu = r              # Expected return\n&quot;, 
    &quot;num_paths = 1000    # Number of paths\n&quot;, 
    &quot;num_steps = 252     # Number of time steps\n&quot;, 
    &quot;\n&quot;, 
    &quot;# Monte Carlo simulation\n&quot;, 
    &quot;PnL_actual = np.zeros(num_paths)\n&quot;, 
    &quot;PnL_iv = np.zeros(num_paths)\n&quot;, 
    &quot;dt = T / num_steps\n&quot;, 
    &quot;\n&quot;, 
    &quot;# Generate Sobol sequence\n&quot;, 
    &quot;sobol_seq = i4_sobol_generate(1, num_paths * num_steps)\n&quot;, 
    &quot;sobol_seq = sobol_seq.reshape(num_paths, num_steps)\n&quot;, 
    &quot;\n&quot;, 
    &quot;for i in range(num_paths):\n&quot;, 
    &quot;    S = np.zeros(num_steps + 1)\n&quot;, 
    &quot;    S[0] = S0\n&quot;, 
    &quot;\n&quot;, 
    &quot;    # Generate paths\n&quot;, 
    &quot;    for j in range(1, num_steps + 1):\n&quot;, 
    &quot;        Z = stats.norm.ppf(sobol_seq[i, j - 1])\n&quot;, 
    &quot;        # Milstein scheme\n&quot;, 
    &quot;        S[j] = S[j - 1] + r * S[j - 1] * dt + sigma_actual * S[j - 1] * np.sqrt(dt) * Z \\\n&quot;, 
    &quot;               + 0.5 * sigma_actual ** 2 * S[j - 1] * (Z ** 2 - 1) * dt\n&quot;, 
    &quot;\n&quot;, 
    &quot;    # Ensure S does not contain zero or negative values\n&quot;, 
    &quot;    S = np.maximum(S, 1e-10)\n&quot;, 
    &quot;\n&quot;, 
    &quot;    # Calculate option prices and Delta hedging\n&quot;, 
    &quot;    C = np.maximum(S - K, 0)  # Intrinsic value of European call option\n&quot;, 
    &quot;\n&quot;, 
    &quot;    # Prevent division by zero or negative numbers\n&quot;, 
    &quot;    time_to_maturity = np.maximum(T - np.arange(num_steps + 1) * dt, 1e-10)\n&quot;, 
    &quot;\n&quot;, 
    &quot;    # Actual volatility hedging\n&quot;, 
    &quot;    d1_actual = (np.log(S / K) + (r + 0.5 * sigma_actual ** 2) * time_to_maturity) / (\n&quot;, 
    &quot;            sigma_actual * np.sqrt(time_to_maturity))\n&quot;, 
    &quot;    delta_actual = stats.norm.cdf(d1_actual)  # Black-Scholes Delta\n&quot;, 
    &quot;\n&quot;, 
    &quot;    # Implied volatility hedging\n&quot;, 
    &quot;    d1_iv = (np.log(S / K) + (r + 0.5 * sigma_iv ** 2) * time_to_maturity) / (\n&quot;, 
    &quot;            sigma_iv * np.sqrt(time_to_maturity))\n&quot;, 
    &quot;    delta_iv = stats.norm.cdf(d1_iv)  # Black-Scholes Delta\n&quot;, 
    &quot;\n&quot;, 
    &quot;    # Calculate P&amp;L\n&quot;, 
    &quot;    portfolio_actual = -C[0]  # Initial portfolio: -C means buying the option\n&quot;, 
    &quot;    portfolio_iv = -C[0]\n&quot;, 
    &quot;    for j in range(num_steps):\n&quot;, 
    &quot;        portfolio_actual += delta_actual[j] * (S[j + 1] - S[j])  # Actual volatility hedging\n&quot;, 
    &quot;        portfolio_iv += delta_iv[j] * (S[j + 1] - S[j])  # Implied volatility hedging\n&quot;, 
    &quot;    PnL_actual[i] = portfolio_actual + C[-1]  # Final portfolio value plus option payoff at maturity\n&quot;, 
    &quot;    PnL_iv[i] = portfolio_iv + C[-1]\n&quot;, 
    &quot;\n&quot;, 
    &quot;# Analyze results\n&quot;, 
    &quot;mean_PnL_actual = np.mean(PnL_actual)\n&quot;, 
    &quot;std_PnL_actual = np.std(PnL_actual)\n&quot;, 
    &quot;mean_PnL_iv = np.mean(PnL_iv)\n&quot;, 
    &quot;std_PnL_iv = np.std(PnL_iv)\n&quot;, 
    &quot;\n&quot;, 
    &quot;print(f\&quot;Mean P&amp;L for actual volatility hedging: {mean_PnL_actual}\&quot;)\n&quot;, 
    &quot;print(f\&quot;Standard deviation of P&amp;L for actual volatility hedging: {std_PnL_actual}\&quot;)\n&quot;, 
    &quot;print(f\&quot;Mean P&amp;L for implied volatility hedging: {mean_PnL_iv}\&quot;)\n&quot;, 
    &quot;print(f\&quot;Standard deviation of P&amp;L for implied volatility hedging: {std_PnL_iv}\&quot;)\n&quot;, 
    &quot;```\n&quot;, 
    &quot;\n&quot;, 
    &quot;This code is for a Monte Carlo simulation using the Milstein scheme for stock price simulation. It computes the P&amp;L for both actual and implied volatility hedging strategies and then analyzes the results. The comments in the code explain the different steps of the process.\n&quot;, 
    &quot;\n&quot;, 
    &quot;The output is as follows:\n&quot;, 
    &quot;\n&quot;, 
    &quot;1. Mean P&amp;L for actual volatility hedging: -6.225461631984515\n&quot;, 
    &quot;\n&quot;, 
    &quot;This indicates that when hedging with actual volatility, the average P&amp;L is negative, suggesting that the hedging strategy incurred losses on average. This may imply that actual volatility hedging did not completely offset the risk introduced by price fluctuations.\n&quot;, 
    &quot;\n&quot;, 
    &quot;2. Standard deviation of P&amp;L for actual volatility hedging: 7.461848805125476\n&quot;, 
    &quot;\n&quot;, 
    &quot;The standard deviation represents the volatility or risk of P&amp;L. A larger standard deviation indicates higher volatility in P&amp;L. In this case, the P&amp;L volatility for actual volatility hedging is relatively high, suggesting that the hedging strategy performs inconsistently under different market conditions.\n&quot;, 
    &quot;\n&quot;, 
    &quot;3. Mean P&amp;L for implied volatility hedging: -9.148463173169842\n&quot;, 
    &quot;\n&quot;, 
    &quot;This signifies that when hedging with implied volatility, the average P&amp;L is also negative, indicating losses on average. This may suggest that implied volatility failed to accurately predict future actual volatility.\n&quot;, 
    &quot;\n&quot;, 
    &quot;4. Standard deviation of P&amp;L for implied volatility hedging: 8.326580230614766\n&quot;, 
    &quot;\n&quot;, 
    &quot;The standard deviation of P&amp;L for implied volatility hedging. Compared to actual volatility hedging, the P&amp;L volatility for implied volatility hedging may be higher, indicating a more unstable performance of the hedging strategy under different market conditions.&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;markdown&quot;, 
   &quot;source&quot;: [ 
    &quot;## Sub-part 3: 其它分析\n&quot;, 
    &quot;\n&quot;, 
    &quot;### 1. 时间依赖的 $Gamma (Γt)$：\n&quot;, 
    &quot;\n&quot;, 
    &quot;$Gamma (Γt)$ 衡量期权Delta相对于标的资产价格变动的变化率。时间依赖的$Gamma (Γt)$考虑了这种敏感度随着期权临近到期如何变化。\n&quot;, 
    &quot;\n&quot;, 
    &quot;- **对P&amp;L的影响**：临近到期时较高的Gamma可能导致Delta发生显著变化，需要频繁调整对冲头寸。这可能会增加交易成本，从而影响P&amp;L。相反，较低的Gamma意味着对标的价格变化的敏感度较低，可能导致对冲头寸更稳定但可能反应不够灵敏。\n&quot;, 
    &quot;\n&quot;, 
    &quot;- **代码实现**：\n&quot;, 
    &quot;```python\n&quot;, 
    &quot;import numpy as np\n&quot;, 
    &quot;import scipy.stats as stats\n&quot;, 
    &quot;from sobol_seq import i4_sobol_generate\n&quot;, 
    &quot;\n&quot;, 
    &quot;# 参数设置\n&quot;, 
    &quot;S0 = 100  # 初始股价\n&quot;, 
    &quot;K = 100  # 行权价\n&quot;, 
    &quot;T = 1.0  # 到期时间\n&quot;, 
    &quot;r = 0.05  # 无风险利率\n&quot;, 
    &quot;sigma_actual = 0.3  # 实际波动率\n&quot;, 
    &quot;mu = r  # 预期收益率\n&quot;, 
    &quot;num_paths = 1000  # 路径数量\n&quot;, 
    &quot;num_steps = 252  # 时间步数量\n&quot;, 
    &quot;\n&quot;, 
    &quot;# 蒙特卡洛模拟\n&quot;, 
    &quot;PnL = np.zeros(num_paths)\n&quot;, 
    &quot;Gamma_t_values = []  # 用于存储各个路径上的Gamma值\n&quot;, 
    &quot;\n&quot;, 
    &quot;dt = T / num_steps\n&quot;, 
    &quot;\n&quot;, 
    &quot;# 生成Sobol序列\n&quot;, 
    &quot;sobol_seq = i4_sobol_generate(1, num_paths * num_steps)\n&quot;, 
    &quot;sobol_seq = sobol_seq.reshape(num_paths, num_steps)\n&quot;, 
    &quot;\n&quot;, 
    &quot;for i in range(num_paths):\n&quot;, 
    &quot;    S = np.zeros(num_steps + 1)\n&quot;, 
    &quot;    S[0] = S0\n&quot;, 
    &quot;    gamma_path = np.zeros(num_steps)  # 存储每个时间步的Gamma值\n&quot;, 
    &quot;\n&quot;, 
    &quot;    # 生成路径\n&quot;, 
    &quot;    for j in range(1, num_steps + 1):\n&quot;, 
    &quot;        Z = stats.norm.ppf(sobol_seq[i, j - 1])\n&quot;, 
    &quot;        S[j] = S[j - 1] + r * S[j - 1] * dt + sigma_actual * S[j - 1] * np.sqrt(dt) * Z \\\n&quot;, 
    &quot;               + 0.5 * sigma_actual ** 2 * S[j - 1] * (Z ** 2 - 1) * dt\n&quot;, 
    &quot;\n&quot;, 
    &quot;    S = np.maximum(S, 1e-10)\n&quot;, 
    &quot;\n&quot;, 
    &quot;    # 计算期权价格和Delta、Gamma对冲\n&quot;, 
    &quot;    d1 = (np.log(S / K) + (r + 0.5 * sigma_actual ** 2) * (T - np.arange(num_steps + 1) * dt)) / (\n&quot;, 
    &quot;            sigma_actual * np.sqrt(T - np.arange(num_steps + 1) * dt))\n&quot;, 
    &quot;    d2 = d1 - sigma_actual * np.sqrt(T - np.arange(num_steps + 1) * dt)\n&quot;, 
    &quot;    C = S * stats.norm.cdf(d1) - K * np.exp(-r * (T - np.arange(num_steps + 1) * dt)) * stats.norm.cdf(d2)\n&quot;, 
    &quot;    delta = stats.norm.cdf(d1)\n&quot;, 
    &quot;    gamma = stats.norm.pdf(d1) / (S * sigma_actual * np.sqrt(T - np.arange(num_steps + 1) * dt))\n&quot;, 
    &quot;\n&quot;, 
    &quot;    # 计算P&amp;L和记录Gamma\n&quot;, 
    &quot;    portfolio = -C[0]  # 初始投资组合：-C表示购买期权\n&quot;, 
    &quot;    for j in range(num_steps):\n&quot;, 
    &quot;        portfolio += delta[j] * (S[j + 1] - S[j])  # Delta对冲\n&quot;, 
    &quot;        gamma_path[j] = gamma[j]\n&quot;, 
    &quot;    PnL[i] = portfolio + C[-1]  # 最终组合价值加上期权到期价值\n&quot;, 
    &quot;    Gamma_t_values.append(gamma_path)\n&quot;, 
    &quot;\n&quot;, 
    &quot;# 分析结果\n&quot;, 
    &quot;mean_PnL = np.mean(PnL)\n&quot;, 
    &quot;std_PnL = np.std(PnL)\n&quot;, 
    &quot;mean_Gamma_t = np.mean(Gamma_t_values, axis=0)  # 计算每个时间步的平均Gamma值\n&quot;, 
    &quot;\n&quot;, 
    &quot;print(f\&quot;Mean P&amp;L: {mean_PnL}\&quot;)\n&quot;, 
    &quot;print(f\&quot;Standard deviation of P&amp;L: {std_PnL}\&quot;)\n&quot;, 
    &quot;\n&quot;, 
    &quot;# 绘图展示Gamma随时间的变化\n&quot;, 
    &quot;import matplotlib.pyplot as plt\n&quot;, 
    &quot;plt.plot(mean_Gamma_t)\n&quot;, 
    &quot;plt.xlabel('Time Steps')\n&quot;, 
    &quot;plt.ylabel('Mean Gamma')\n&quot;, 
    &quot;plt.title('Mean Gamma Over Time')\n&quot;, 
    &quot;plt.show()\n&quot;, 
    &quot;\n&quot;, 
    &quot;```\n&quot;, 
    &quot;\n&quot;, 
    &quot;- **输出结果分析**：\n&quot;, 
    &quot;1. Mean P&amp;L: -20.456716417970334\n&quot;, 
    &quot;\n&quot;, 
    &quot;2. Standard deviation of P&amp;L: 7.461848805125476\n&quot;, 
    &quot;\n&quot;, 
    &quot;3. figure:\n&quot;, 
    &quot;    &lt;img src=\&quot;gamma.png\&quot; alt=\&quot;示例图片\&quot; width=\&quot;300px\&quot;&gt;\n&quot;, 
    &quot;\n&quot;, 
    &quot;\n&quot;, 
    &quot;图表显示，Mean Gamma随时间步的增加而上升，并在接近期权到期时显著增加。这是一个符合期权定价理论的预期结果。具体地：\n&quot;, 
    &quot;\n&quot;, 
    &quot;    - **Gamma值的增长**：在期权的有效期内，Gamma值通常在期权临近到期时变得更大。这是因为，随着到期日的临近，标的资产的微小价格变动对期权内在价值的影响增大，Delta变化加快，从而Gamma值上升。\n&quot;, 
    &quot;\n&quot;, 
    &quot;    - **期权到期前的尖峰**：从图中可以看出，Gamma值在时间序列的最后部分出现尖峰，这表明期权在到期前的最后几个时间步内变得非常敏感，即使是很小的标的资产价格变动也会导致Delta的显著变化。\n&quot;, 
    &quot;\n&quot;, 
    &quot;    - **对冲策略的影响**：高Gamma值意味着对冲者需要更频繁地调整其对冲头寸，尤其是在期权到期前。这可能导致交易成本的上升，并可能引起P&amp;L的波动。&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;markdown&quot;, 
   &quot;source&quot;: [ 
    &quot;### 2. $ r^2 - \\sigma_{imp} \\delta t $项：\n&quot;, 
    &quot;\n&quot;, 
    &quot;这个项结合了无风险利率的平方(r2)，隐含波动率($\\sigma_{imp}$)和一个小时间间隔($\\delta t$)。\n&quot;, 
    &quot;\n&quot;, 
    &quot;- **对P&amp;L的影响**：无风险利率影响持有头寸的成本，而隐含波动率影响期权的时间价值。这些因素与时间的推移($\\delta t$)的相互作用可能对P&amp;L产生复杂的影响。\n&quot;, 
    &quot;\n&quot;, 
    &quot;- **代码实现**：\n&quot;, 
    &quot;\n&quot;, 
    &quot;```python\n&quot;, 
    &quot;import numpy as np\n&quot;, 
    &quot;import scipy.stats as stats\n&quot;, 
    &quot;from matplotlib import pyplot as plt\n&quot;, 
    &quot;from sobol_seq import i4_sobol_generate\n&quot;, 
    &quot;\n&quot;, 
    &quot;# 参数设置\n&quot;, 
    &quot;S0 = 100  # 初始股价\n&quot;, 
    &quot;K = 100  # 行权价\n&quot;, 
    &quot;T = 1.0  # 到期时间\n&quot;, 
    &quot;r = 0.05  # 无风险利率\n&quot;, 
    &quot;sigma_actual = 0.3  # 实际波动率\n&quot;, 
    &quot;sigma_imp = 0.2    # 隐含波动率\n&quot;, 
    &quot;mu = r             # 预期收益率\n&quot;, 
    &quot;num_paths = 1000   # 路径数量\n&quot;, 
    &quot;num_steps = 252    # 时间步数量\n&quot;, 
    &quot;dt = T / num_steps # 时间步长度\n&quot;, 
    &quot;\n&quot;, 
    &quot;# 生成Sobol序列\n&quot;, 
    &quot;sobol_seq = i4_sobol_generate(1, num_paths * num_steps).flatten()\n&quot;, 
    &quot;\n&quot;, 
    &quot;# 蒙特卡洛模拟\n&quot;, 
    &quot;PnL = np.zeros(num_paths)\n&quot;, 
    &quot;time_steps = np.linspace(0, T, num_steps + 1)\n&quot;, 
    &quot;\n&quot;, 
    &quot;\n&quot;, 
    &quot;for i in range(num_paths):\n&quot;, 
    &quot;    S = np.zeros(num_steps + 1)\n&quot;, 
    &quot;    S[0] = S0\n&quot;, 
    &quot;    r_squared_term = r**2 * dt\n&quot;, 
    &quot;    sigma_imp_term = sigma_imp * dt\n&quot;, 
    &quot;\n&quot;, 
    &quot;    # 生成路径\n&quot;, 
    &quot;    for j in range(1, num_steps + 1):\n&quot;, 
    &quot;        Z = stats.norm.ppf(sobol_seq[i * num_steps + j - 1])\n&quot;, 
    &quot;        S[j] = S[j - 1] * (1 + mu * dt + sigma_actual * np.sqrt(dt) * Z)\n&quot;, 
    &quot;\n&quot;, 
    &quot;    # 计算期权Delta对冲\n&quot;, 
    &quot;    d1 = (np.log(S[:-1] / K) + (r + 0.5 * sigma_imp**2) * (T - np.arange(num_steps) * dt)) / (sigma_imp * np.sqrt(T - np.arange(num_steps) * dt))\n&quot;, 
    &quot;    delta = stats.norm.cdf(d1)\n&quot;, 
    &quot;\n&quot;, 
    &quot;    # 计算对冲成本\n&quot;, 
    &quot;    cost_of_hedging = np.cumsum(delta * (S[1:] - S[:-1]))\n&quot;, 
    &quot;\n&quot;, 
    &quot;    # 计算P&amp;L\n&quot;, 
    &quot;    final_option_value = max(S[-1] - K, 0)\n&quot;, 
    &quot;    PnL[i] = final_option_value - cost_of_hedging[-1] - (r_squared_term - sigma_imp_term)\n&quot;, 
    &quot;\n&quot;, 
    &quot;# 分析结果\n&quot;, 
    &quot;mean_PnL = np.mean(PnL)\n&quot;, 
    &quot;std_PnL = np.std(PnL)\n&quot;, 
    &quot;\n&quot;, 
    &quot;print(f\&quot;Mean P&amp;L: {mean_PnL}\&quot;)\n&quot;, 
    &quot;print(f\&quot;Standard deviation of P&amp;L: {std_PnL}\&quot;)\n&quot;, 
    &quot;\n&quot;, 
    &quot;# 输出图像展示\n&quot;, 
    &quot;plt.figure(figsize=(12, 6))\n&quot;, 
    &quot;\n&quot;, 
    &quot;# P&amp;L的直方图\n&quot;, 
    &quot;plt.subplot(1, 2, 1)\n&quot;, 
    &quot;plt.hist(PnL, bins=50, color='blue', edgecolor='black')\n&quot;, 
    &quot;plt.title('Histogram of P&amp;L')\n&quot;, 
    &quot;plt.xlabel('P&amp;L')\n&quot;, 
    &quot;plt.ylabel('Frequency')\n&quot;, 
    &quot;\n&quot;, 
    &quot;# P&amp;L随时间变化的路径\n&quot;, 
    &quot;plt.subplot(1, 2, 2)\n&quot;, 
    &quot;for i in range(min(10, num_paths)):  # 只绘制部分路径\n&quot;, 
    &quot;    plt.plot(time_steps, np.cumsum(np.insert(delta * (S[1:] - S[:-1]), 0, 0)), label=f'Path {i+1}')\n&quot;, 
    &quot;plt.title('P&amp;L Paths Over Time')\n&quot;, 
    &quot;plt.xlabel('Time (Years)')\n&quot;, 
    &quot;plt.ylabel('Cumulative P&amp;L')\n&quot;, 
    &quot;plt.legend()\n&quot;, 
    &quot;\n&quot;, 
    &quot;plt.tight_layout()\n&quot;, 
    &quot;plt.show()\n&quot;, 
    &quot;```\n&quot;, 
    &quot;\n&quot;, 
    &quot;- **输出结果分析**：\n&quot;, 
    &quot;1. Mean P&amp;L: 14.489793353691867\n&quot;, 
    &quot;   - 这表示在您的蒙特卡洛模拟中，对冲策略平均盈利约为14.49单位货币。\n&quot;, 
    &quot;   - 这是一个正值，意味着在模拟期间，平均而言，对冲策略是盈利的。\n&quot;, 
    &quot;\n&quot;, 
    &quot;2. Standard deviation of P&amp;L: 1.6896365372497164\n&quot;, 
    &quot;   - 这个值表示在不同模拟路径上P&amp;L的波动性或分散程度。\n&quot;, 
    &quot;   - 标准差较小，意味着大多数路径上的盈亏相对于平均值而言没有很大的波动；换句话说，对冲策略的结果比较稳定。\n&quot;, 
    &quot;   - 低标准差通常被视为风险较低，因为P&amp;L的波动较小，预测未来绩效的不确定性较低。\n&quot;, 
    &quot;\n&quot;, 
    &quot;3. figure:\n&quot;, 
    &quot;    &lt;img src=\&quot;特别项.png\&quot; alt=\&quot;示例图片\&quot; width=\&quot;300px\&quot;&gt;\n&quot;, 
    &quot;\n&quot;, 
    &quot;**直方图（Histogram of P&amp;L）**：\n&quot;, 
    &quot;   - 这个直方图显示了P&amp;L（盈亏）的分布情况。\n&quot;, 
    &quot;   - 大多数的P&amp;L值集中在一个范围内，这表明大部分的对冲路径产生了相似大小的P&amp;L。\n&quot;, 
    &quot;   - P&amp;L分布看起来是单峰的，这意味着大多数对冲结果都围绕着某个中心值波动。\n&quot;, 
    &quot;   - 如果直方图显示的P&amp;L值主要集中在正值，那么表明对冲策略通常是盈利的；如果主要集中在负值，则表明对冲策略通常是亏损的。\n&quot;, 
    &quot;\n&quot;, 
    &quot;**P&amp;L路径图（P&amp;L Paths Over Time）**：\n&quot;, 
    &quot;   - 这个图表显示了选取的十条路径的累计P&amp;L随时间的变化情况。\n&quot;, 
    &quot;   - 每条路径代表一个特定的股价路径和相应的对冲操作所导致的累计P&amp;L变化。\n&quot;, 
    &quot;   - 从图中可以看出，不同路径的P&amp;L随时间变化的趋势大致相似，但具体数值各不相同，表明市场条件和对冲操作的随机性对P&amp;L有显著影响。\n&quot;, 
    &quot;   - 如果路径在时间序列的后期出现较大跌幅，这可能表明期权接近到期时P&amp;L的不稳定性增加，或者表明在某些路径中发生了较大的市场价格波动，导致对冲策略的P&amp;L波动。\n&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false 
   } 
  }, 
  { 
   &quot;cell_type&quot;: &quot;markdown&quot;, 
   &quot;source&quot;: [ 
    &quot;### 3. 使用较小Delta对冲的含义：\n&quot;, 
    &quot;\n&quot;, 
    &quot;根据第二部分MVD（最小方差Delta）建模，使用较小的delta（即使对冲误差的方差最小化的delta）对冲具有含义。\n&quot;, 
    &quot;\n&quot;, 
    &quot;- **对P&amp;L的影响**：使用较小的delta对冲旨在最小化对冲投资组合的方差，可能导致更稳定的P&amp;L概况。然而，它也可能意味着投资组合对标的资产价格的大幅度变动反应不够灵敏，这可能是有利的，也可能是不利的，取决于市场的走势。\n&quot;, 
    &quot;\n&quot;, 
    &quot;- **代码实现**:\n&quot;, 
    &quot;\n&quot;, 
    &quot;```python\n&quot;, 
    &quot;import numpy as np\n&quot;, 
    &quot;import scipy.stats as stats\n&quot;, 
    &quot;import matplotlib.pyplot as plt\n&quot;, 
    &quot;from sobol_seq import i4_sobol_generate\n&quot;, 
    &quot;\n&quot;, 
    &quot;# Parameter settings\n&quot;, 
    &quot;S0 = 100  # Initial stock price\n&quot;, 
    &quot;K = 100   # Strike price\n&quot;, 
    &quot;T = 1.0   # Time to maturity\n&quot;, 
    &quot;r = 0.05  # Risk-free rate\n&quot;, 
    &quot;sigma_actual = 0.3  # Actual volatility\n&quot;, 
    &quot;mu = r              # Expected return\n&quot;, 
    &quot;num_paths = 1000    # Number of paths\n&quot;, 
    &quot;num_steps = 252     # Number of time steps\n&quot;, 
    &quot;dt = T / num_steps  # Time step size\n&quot;, 
    &quot;\n&quot;, 
    &quot;# Generate Sobol sequence\n&quot;, 
    &quot;sobol_seq = i4_sobol_generate(1, num_paths * num_steps).flatten()\n&quot;, 
    &quot;\n&quot;, 
    &quot;# Monte Carlo simulation\n&quot;, 
    &quot;PnL_traditional = np.zeros(num_paths)\n&quot;, 
    &quot;PnL_small_delta = np.zeros(num_paths)\n&quot;, 
    &quot;\n&quot;, 
    &quot;for i in range(num_paths):\n&quot;, 
    &quot;    S = np.zeros(num_steps + 1)\n&quot;, 
    &quot;    S[0] = S0\n&quot;, 
    &quot;\n&quot;, 
    &quot;    # Generate paths\n&quot;, 
    &quot;    for j in range(1, num_steps + 1):\n&quot;, 
    &quot;        Z = stats.norm.ppf(sobol_seq[i * num_steps + j - 1])\n&quot;, 
    &quot;        S[j] = S[j - 1] * (1 + mu * dt + sigma_actual * np.sqrt(dt) * Z)\n&quot;, 
    &quot;\n&quot;, 
    &quot;    # Calculate option Delta hedging\n&quot;, 
    &quot;    d1 = (np.log(S[:-1] / K) + (r + 0.5 * sigma_actual ** 2) * (T - np.arange(num_steps) * dt)) / (sigma_actual * np.sqrt(T - np.arange(num_steps) * dt))\n&quot;, 
    &quot;    delta_traditional = stats.norm.cdf(d1)\n&quot;, 
    &quot;    delta_small = delta_traditional * 0.9  # Using a smaller delta for hedging\n&quot;, 
    &quot;\n&quot;, 
    &quot;    # Calculate P&amp;L\n&quot;, 
    &quot;    option_payoff = np.maximum(S[-1] - K, 0)\n&quot;, 
    &quot;    PnL_traditional[i] = option_payoff - np.cumsum(delta_traditional * (S[1:] - S[:-1]))[-1]\n&quot;, 
    &quot;    PnL_small_delta[i] = option_payoff - np.cumsum(delta_small * (S[1:] - S[:-1]))[-1]\n&quot;, 
    &quot;\n&quot;, 
    &quot;# Analyze results\n&quot;, 
    &quot;mean_PnL_traditional = np.mean(PnL_traditional)\n&quot;, 
    &quot;std_PnL_traditional = np.std(PnL_traditional)\n&quot;, 
    &quot;mean_PnL_small_delta = np.mean(PnL_small_delta)\n&quot;, 
    &quot;std_PnL_small_delta = np.std(PnL_small_delta)\n&quot;, 
    &quot;\n&quot;, 
    &quot;# Plotting the results\n&quot;, 
    &quot;plt.figure(figsize=(14, 7))\n&quot;, 
    &quot;\n&quot;, 
    &quot;# Histogram of traditional Delta hedging P&amp;L\n&quot;, 
    &quot;plt.subplot(1, 2, 1)\n&quot;, 
    &quot;plt.hist(PnL_traditional, bins=50, alpha=0.7, label='Traditional Delta Hedging')\n&quot;, 
    &quot;plt.hist(PnL_small_delta, bins=50, alpha=0.7, label='Small Delta Hedging')\n&quot;, 
    &quot;plt.xlabel('P&amp;L')\n&quot;, 
    &quot;plt.ylabel('Frequency')\n&quot;, 
    &quot;plt.title('Histogram of P&amp;L')\n&quot;, 
    &quot;plt.legend()\n&quot;, 
    &quot;\n&quot;, 
    &quot;# P&amp;L paths over time for a few paths\n&quot;, 
    &quot;plt.subplot(1, 2, 2)\n&quot;, 
    &quot;sample_paths = np.random.choice(num_paths, size=10, replace=False)\n&quot;, 
    &quot;for i in sample_paths:\n&quot;, 
    &quot;    plt.plot(np.cumsum(delta_traditional * (S[1:] - S[:-1])), label=f'Path {i+1} Traditional')\n&quot;, 
    &quot;    plt.plot(np.cumsum(delta_small * (S[1:] - S[:-1])), label=f'Path {i+1} Small Delta', alpha=0.7)\n&quot;, 
    &quot;plt.xlabel('Time Steps')\n&quot;, 
    &quot;plt.ylabel('Cumulative P&amp;L')\n&quot;, 
    &quot;plt.title('P&amp;L Paths Over Time')\n&quot;, 
    &quot;plt.legend()\n&quot;, 
    &quot;\n&quot;, 
    &quot;plt.tight_layout()\n&quot;, 
    &quot;plt.show()\n&quot;, 
    &quot;\n&quot;, 
    &quot;# Print the results\n&quot;, 
    &quot;print(f\&quot;Mean P&amp;L for traditional volatility hedging: {mean_PnL_traditional}\&quot;)\n&quot;, 
    &quot;print(f\&quot;Standard deviation of P&amp;L for traditional volatility hedging: {std_PnL_traditional}\&quot;)\n&quot;, 
    &quot;print(f\&quot;Mean P&amp;L for small delta hedging: {mean_PnL_small_delta}\&quot;)\n&quot;, 
    &quot;print(f\&quot;Standard deviation of P&amp;L for small delta hedging: {std_PnL_small_delta}\&quot;)\n&quot;, 
    &quot;\n&quot;, 
    &quot;```\n&quot;, 
    &quot;\n&quot;, 
    &quot;- **输出结果分析**：\n&quot;, 
    &quot;1. Mean P&amp;L for traditional volatility hedging: 11.578686616741932\n&quot;, 
    &quot;    - 这意味着对冲策略平均盈利约为11.58单位货币\n&quot;, 
    &quot;\n&quot;, 
    &quot;2. Standard deviation of P&amp;L for traditional volatility hedging: 0.6601932633974179\n&quot;, 
    &quot;    - 传统Delta对冲的标准差为0.6602，说明P&amp;L的波动范围相对较宽。\n&quot;, 
    &quot;\n&quot;, 
    &quot;3. Mean P&amp;L for small delta hedging: 10.689379414770666\n&quot;, 
    &quot;    - 小Delta对冲的平均P&amp;L为10.6894，略低于传统Delta对冲，但差距不大。\n&quot;, 
    &quot;\n&quot;, 
    &quot;4. Standard deviation of P&amp;L for small delta hedging: 0.5394603400279799\n&quot;, 
    &quot;    - 小Delta对冲的标准差为0.5395，较传统Delta对冲的波动性更小，表明使用小Delta对冲的稳定性更高。\n&quot;, 
    &quot;\n&quot;, 
    &quot;5. figure:\n&quot;, 
    &quot;    &lt;img src=\&quot;小delta.png\&quot; alt=\&quot;示例图片\&quot; width=\&quot;300px\&quot;&gt;\n&quot;, 
    &quot;\n&quot;, 
    &quot;**直方图（Histogram of P&amp;L）**：\n&quot;, 
    &quot;   - 直方图显示了两种对冲策略的P&amp;L分布情况。传统Delta对冲策略的P&amp;L分布（蓝色）显示出比较宽的分布，而小Delta对冲策略的P&amp;L分布（橙色）则相对狭窄。\n&quot;, 
    &quot;   - 这表明传统Delta对冲策略的盈亏波动性较大，而小Delta对冲策略则更为稳定，其P&amp;L的波动较小。\n&quot;, 
    &quot;\n&quot;, 
    &quot;**P&amp;L路径图（P&amp;L Paths Over Time）**：\n&quot;, 
    &quot;   - 该图表显示了传统和小Delta对冲策略的几条随机选取的路径。可以看到，虽然两种策略的路径在趋势上相似，但是传统Delta策略的波动性较高。\n&quot;, 
    &quot;   - 对于每条路径，小Delta策略的累计P&amp;L变化较为平滑，这意味着其对市场变动的反应性降低，但在大市波动时可能会减少潜在的亏损。\n&quot;, 
    &quot;\n&quot;, 
    &quot;综合上述分析，小Delta对冲策略在降低P&amp;L波动（提高稳定性）方面取得了一定的效果，但也牺牲了一些盈利潜力。这些发现验证了对冲策略中稳定性与响应性之间的权衡关系。&quot; 
   ], 
   &quot;metadata&quot;: { 
    &quot;collapsed&quot;: false 
   } 
  } 
 ], 
 &quot;metadata&quot;: { 
  &quot;kernelspec&quot;: { 
   &quot;display_name&quot;: &quot;Python 3 (ipykernel)&quot;, 
   &quot;language&quot;: &quot;python&quot;, 
   &quot;name&quot;: &quot;python3&quot; 
  }, 
  &quot;language_info&quot;: { 
   &quot;codemirror_mode&quot;: { 
    &quot;name&quot;: &quot;ipython&quot;, 
    &quot;version&quot;: 3 
   }, 
   &quot;file_extension&quot;: &quot;.py&quot;, 
   &quot;mimetype&quot;: &quot;text/x-python&quot;, 
   &quot;name&quot;: &quot;python&quot;, 
   &quot;nbconvert_exporter&quot;: &quot;python&quot;, 
   &quot;pygments_lexer&quot;: &quot;ipython3&quot;, 
   &quot;version&quot;: &quot;3.10.0&quot; 
  } 
 }, 
 &quot;nbformat&quot;: 4, 
 &quot;nbformat_minor&quot;: 4 
} 
</span></pre>
</body>
</html>